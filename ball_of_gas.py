# -*- coding: utf-8 -*-
"""Ball_of_gas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XCi4cOVaquivdaBA-1DjTktqBP-XVO-P
"""

import math
import sys
import numpy
from array import *
from google.colab import files

# problem params
e : float = 18.6105 #energy in the center
mass: float = 1000. #mass of the ball
init_radius: float = 1.
init_velocity: float = 0.1
gamma: float = 4. / 3.

# calculation parameters
final_time : float = 0.5  # computation time
time_step: float = 0.001  # time step for output
step_r: float = 0.01  # radius step for output
step_R: float = 0.00001  # step for R_bisection
defect: float = 0.001  # defect for R_bisection

# auxiliary quantity
A : float = e / 3 / ((3 * mass / 4 / math.pi / (init_radius ** 3)) ** (1/3))

print(A)

def velocity(r: float, f: float):
    return r * f

def pressure(r: float, R: float, ddot_R: float):
    return 3. * mass / 4. / math.pi * ddot_R / 2. / R / R * (1. - r * r / R / R)

def time_through_R(init_rad : float, init_vel : float, R: float, branch: float):
    if gamma != 4. / 3.:
        return -1000

    r0 = init_rad
    c0 = 4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.)
    b = c0 / r0 + init_vel * init_vel
    c1 = branch * (c0 / 2. / b ** (3. / 2.) * math.log(2. * math.sqrt(b) * init_rad * math.sqrt(
        b - c0 / init_rad) + 2. * b * init_rad - c0) + init_rad * math.sqrt(b - c0 / init_rad) / b)

    result = branch * (c0 * math.log(2. * math.sqrt(b) * R * math.sqrt(b - c0 / R) + 2. * b * R - c0) / 2. / (
                b ** (3. / 2.)) + R * math.sqrt(b - c0 / R) / b) - c1

    return result

def R_bisection(init_rad : float, init_vel : float, exact_time: float, branch : float, step: float, defect: float):
    r = init_rad
    time = time_through_R(init_rad, init_vel, init_rad, branch)

    r0 = init_rad
    c0 = 4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.)
    b = c0 / r0 + init_vel * init_vel

    while math.fabs(time - exact_time) > defect:
        if branch > 0:
            r += step
        else:
            r -= step
        tmp = b - c0 / r
        if tmp < 0:
            break
        time = time_through_R(init_rad, init_vel, r, branch)
    return r


def density(init_rad : float, init_vel : float, exact_time: float, branch : float, step: float, defect: float):
    R = R_bisection(init_rad, init_vel, exact_time, branch, step, defect)
    return 3. * mass / 4. / math.pi / math.pow(R, 3)

def solution(exact_time: float, step_r: float, step_R: float, defect: float):

    rad_arr = []
    vel_arr = []
    dens_arr = []
    pres_arr = []

    branch: float = init_velocity / math.fabs(init_velocity)
    print('branch: ', branch)

    dens : float = 0
    collaps_time : float = 0
    c0 = 4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.)
    critical_radius : float = c0 * init_radius / (c0 + (init_velocity ** 2) * init_radius)
    collaps_time = time_through_R(init_radius, init_velocity, critical_radius, branch)
    print('collaps time: ', collaps_time)

    if branch > 0:

        R = R_bisection(init_radius, init_velocity, exact_time, branch, step_R, defect)
        dens = density(init_radius, init_velocity, exact_time, branch, step_R, defect)
        dot_R: float = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / init_radius - 1. / R)
                                          + math.pow(init_velocity, 2))
        ddot_R: float = 2. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) / R / R
        f: float = dot_R / R

        for radius in numpy.arange(0, R, step_r):
            rad_arr.append(radius)
            vel_arr.append(velocity(radius, f))
            pres_arr.append(pressure(radius, R, ddot_R))

    if branch < 0 and exact_time < collaps_time:

        R = R_bisection(init_radius, init_velocity, exact_time, branch, step_R, defect)
        dens = density(init_radius, init_velocity, exact_time, branch, step_R, defect)
        dot_R: float = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / init_radius - 1. / R)
                                          + math.pow(init_velocity, 2))
        ddot_R: float = 2. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) / R / R
        f: float = dot_R / R

        for radius in numpy.arange(0, R, step_r):
            rad_arr.append(radius)
            vel_arr.append(velocity(radius, f))
            pres_arr.append(pressure(radius, R, ddot_R))

    if branch < 0 and exact_time > collaps_time:

        extension_time: float = exact_time - collaps_time
        extension_init_vel = 0
        extension_init_rad = critical_radius
        branch = 1

        R = R_bisection(extension_init_rad, extension_init_vel, extension_time, branch, step_R, defect)
        dens = density(extension_init_rad, extension_init_vel, extension_time, branch, step_R, defect)
        dot_R = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / extension_init_rad - 1. / R)
                                   + math.pow(extension_init_vel, 2))
        ddot_R: float = 2. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) / R / R
        f: float = dot_R / R

        rad_arr = [0. for x in range(len(rad_arr))]
        vel_arr = [0. for x in range(len(vel_arr))]
        pres_arr = [0. for x in range(len(pres_arr))]

        for radius in numpy.arange(0, R, step_r):
            rad_arr.append(radius)
            vel_arr.append(velocity(radius, f))
            pres_arr.append(pressure(radius, R, ddot_R))

    with open('ball_solution.dat', 'w') as file:
        file.write('#radius velocity pressure density; time = ' + str(final_time) + '\n')
        for i in range(0, len(rad_arr)):
            file.write(str(rad_arr[i]) + ' ' + str(vel_arr[i]) + ' ' + str(pres_arr[i]) + ' ' + str(dens) + '\n')
    files.download('ball_solution.dat')

def time_dependence(exact_time: float, step_r: float, step_R: float, defect: float):

    rad_arr = []
    vel_arr = []
    dens_arr = []
    time_arr = []

    dens: float = 0
    collaps_time: float = 0
    c0 = 4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.)
    critical_radius: float = c0 * init_radius / (c0 + (init_velocity ** 2) * init_radius)

    branch: float = init_velocity / math.fabs(init_velocity)
    collaps_time = time_through_R(init_radius, init_velocity, critical_radius, branch)

    if branch > 0:
        for t in numpy.arange(0, exact_time+time_step, time_step):
            print('t = ', t)
            R = R_bisection(init_radius, init_velocity, t, branch, step_R, defect)
            dot_R = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / init_radius - 1. / R)
                                       + math.pow(init_velocity, 2))
            f = dot_R / R

            time_arr.append(t)
            rad_arr.append(R)
            dens_arr.append(density(init_radius, init_velocity, t, branch, step_R, defect))
            vel_arr.append(velocity(R, f))

    if branch < 0 and exact_time < collaps_time:
        for t in numpy.arange(0, exact_time + time_step, time_step):
            print('t = ', t)
            R = R_bisection(init_radius, init_velocity, t, branch, step_R, defect)
            dot_R = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / init_radius - 1. / R)
                                       + math.pow(init_velocity, 2))
            f = dot_R / R

            time_arr.append(t)
            rad_arr.append(R)
            dens_arr.append(density(init_radius, init_velocity, t, branch, step_R, defect))
            vel_arr.append(velocity(R, f))

    if branch < 0 and exact_time > collaps_time:
        for t in numpy.arange(0, exact_time + time_step, time_step):
            print('t = ', t)
            if t < collaps_time:
                R = R_bisection(init_radius, init_velocity, t, branch, step_R, defect)
                dot_R = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / init_radius - 1. / R)
                    + math.pow(init_velocity, 2))
                f = dot_R / R

                time_arr.append(t)
                rad_arr.append(R)
                dens_arr.append(density(init_radius, init_velocity, t, branch, step_R, defect))
                vel_arr.append(velocity(R, f))
            else:
                branch = 1
                extension_time: float = t - collaps_time
                extension_init_vel = 0
                extension_init_rad = critical_radius

                R = R_bisection(extension_init_rad, extension_init_vel, extension_time, branch, step_R, defect)
                dot_R = branch * math.sqrt(4. * A * (3. * mass / 4. / math.pi) ** (1. / 3.) * (1. / extension_init_rad - 1. / R)
                    + math.pow(extension_init_vel, 2))
                f = dot_R / R

                time_arr.append(t)
                rad_arr.append(R)
                dens_arr.append(density(extension_init_rad, extension_init_vel, extension_time, branch, step_R, defect))
                vel_arr.append(velocity(R, f))


    with open('r(t).dat', 'w') as file:
        file.write('#radius velocity density; \n')
        for i in range(0, len(rad_arr)):
            file.write(str(time_arr[i]) + ' ' + str(rad_arr[i]) + ' ' + str(vel_arr[i]) + ' ' + str(dens_arr[i]) + '\n')
    files.download('r(t).dat')

if __name__ == "__main__":
    solution(final_time, step_r, step_R, defect)
    time_dependence(final_time, step_r, step_R, defect)